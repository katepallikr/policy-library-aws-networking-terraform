import "tfplan/v2" as tfplan
import "tfconfig"
import "strings"

# Define the main rule for resource changes
resource_changes_rule = rule {
    all tfplan.resource_changes as rc {
        all rc.change.actions as action {
            action in ["create", "update"]
        }
    }
}

# List of approved module sources
approved_module_sources = [
    "app.terraform.io/Cloud-Operations/s3-bucket/aws",
    "app.terraform.io/Cloud-Operations/vpc/aws",
    "hashicorp/consul/aws",
    "terraform-aws-modules/vpc/aws",
]

# Function to check if a module source is approved
is_approved_module = func(source) {
    for approved_source in approved_module_sources {
        if strings.has_prefix(source, approved_source) {
            return true
        }
    }
    return false
}

# Rule to check if all modules are approved (Corrected syntax)
approved_modules_rule = rule {
    all tfconfig.module_calls as module_call {  // Iterate with 'as'
        is_approved_module(module_call.source)  // Access source property
    }
}

# Enhanced output with more context
violating_modules = [module_call.name | tfconfig.module_calls as module_call { not is_approved_module(module_call.source) }]

# Main rule
main = rule {
    resource_changes_rule and approved_modules_rule and count(violating_modules) == 0
}

# Updated error message to display module names
print(rule {
    not main
    message := sprintf("The following modules are not approved: %v", [violating_modules])
})
# Helper function to get unapproved module names
get_unapproved_modules = func() {
  unapproved = []
  for module_call in tfconfig.module_calls {
    if not is_approved_module(module_call.source) {
      append(unapproved, module_call.name)
    }
  }
  return unapproved
}


# Error message using the helper function
print(rule {
    not main
    message := sprintf("The following modules are not approved: %v", [get_unapproved_modules()])
})
